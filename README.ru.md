<p>
  <img  src="https://img.shields.io/github/stars/BEPb/Programmer_Competency_Matrix" />
  <img src="https://img.shields.io/github/contributors/BEPb/Programmer_Competency_Matrix" />
  <img src="https://img.shields.io/github/last-commit/BEPb/Programmer_Competency_Matrix" />
  <img src="https://visitor-badge.laobi.icu/badge?page_id=BEPb.Programmer_Competency_Matrix" />
  <img src="https://img.shields.io/github/languages/count/BEPb/Programmer_Competency_Matrix" />
  <img src="https://img.shields.io/github/languages/top/BEPb/Programmer_Competency_Matrix" />
  <img src="https://img.shields.io/badge/license-MIT-blue.svg?color=f64152" />
  <img  src="https://img.shields.io/github/issues/BEPb/Programmer_Competency_Matrix" />
  <img  src="https://img.shields.io/github/issues-pr/BEPb/Programmer_Competency_Matrix" />
</p>
<div align="center">


<img src="./art/logo.png" alt="Bot logo" width="400" height="300">

# Матрица компетентности программиста

</div>

Прочитать версию на другом языке: [English](README.md)

## Всем привет. 

Сегодня 13 марта 2023 года, и так уж получилось что более 3 лет я активно изучае программирование на питоне а так 
же науку о данных. Через половину года заканчивается контракт и я решил - пришло время смены деятельности из 
радиоинженера в специалиста машинного обучения. Но как оценить себя, как показать будущему работодателю что я знаю, 
умею, как развиваюсь??? Разделяй и властвуй (лат. divide et impera) - глосит максима римского сената, подойдем 
системно к ответу на заданный вопрос. Разделим все составляющие моих знаний специалиста и оценим их используюя 
матрицу компетентности. 

разумеется я не стал изобретать велосипед и взял уже готовую матрицу (наиболее рапроспространенный вариант предложен 
Сидзин Джозефом [вот](https://sijinjoseph.netlify.app/programmer-competency-matrix/)) и честно отвечал на указанные вопросы, ответ старательно складывал в отдельные файлы.


#### В процессе...


<details>
           <summary>Знания данных, алгоритмы, ПО</summary>
 
- [ ] **Структуры данных**
   - [x] [Уровень 0](#Разница-между-массивом-и-связным-списком) - Не знает разницы между массивом и связанным списком
   - [x] [Уровень 1](#Применение-различных-структур-данных-python-в-различных-алгоритмах) - Способность объяснять и 
     использовать массивы, связанные списки, словари и т. д. в практических задачах программирования 
   - [x] Уровень 2 - Знает компромиссы между пространством и временем для основных структур данных, Массивы и 
     связанные списки, Способен объяснить как хеш-таблицы могут быть реализованы и могут обрабатывать коллизии, 
     приоритетные очереди и способы их реализации и т. д.
   - [x] Уровень 3 - Знание расширенных структур данных, таких как B-деревья, биномиальные кучи и кучи Фибоначчи, деревья AVL/Red Black,
     Развернуть деревья, списки пропусков, попытки и т. д.

- [ ] **Алгоритмы**
   - [x] Уровень 0 - Невозможно найти среднее число чисел в массиве (Сложно поверить, но я проводил собеседования с такими кандидатами)
   - [x] Уровень 1 - Базовые алгоритмы сортировки, поиска и обхода структуры данных и извлечения
   - [x] Уровень 2 - Дерево, График, простые жадные алгоритмы и алгоритмы "разделяй и властвуй", способен понимать
     актуальность уровней этой матрицы.
   - [ ] Уровень 3 - Способность распознавать и кодировать решения динамического программирования, хорошее знание графовых алгоритмов,
     хорошее знание алгоритмов численных вычислений, способность идентифицировать проблемы NP и т. д.
    
- [ ] **Системное программирование**
   - [x] Уровень 0 - Не знает, что такое компилятор, компоновщик или интерпретатор
   - [x] Уровень 1 - Базовое понимание компиляторов, компоновщиков и интерпретаторов. Понимает, что такое ассемблерный код и
     как все работает на аппаратном уровне. Некоторые знания о виртуальной памяти и подкачке.
   - [ ] Уровень 2 — понимание режима ядра и пользовательского режима, многопоточности, примитивов синхронизации и того, как они работают.
         реализован, способен читать ассемблерный код. Понимает, как работают сети, понимает сетевые протоколы и
         программирование на уровне сокетов.
   - [ ] Уровень 3 - Понимает весь программный стек, оборудование (ЦП + Память + Кэш +
         прерывания + микрокод), бинарный код, сборка, статическая и динамическая компоновка, компиляция, интерпретация, JIT
         компиляция, сборка мусора, куча, стек, адресация памяти...

</details>



### Разница между массивом и связным списком 

Разница между массивом и связным списком заключается в том, что массив представляет собой статическую структуру 
данных, а связный список является динамической структурой данных. 

Массив и связный список - это две основные структуры данных, используемые для хранения и управления набором объектов.
Они имеют следующие отличия: 

Память: Массив в основном занимает непрерывный блок памяти, где каждый элемент имеет свой индекс. Связный список 
использует "узлы", каждый из которых содержит указатель на следующий элемент списка и данные этого элемента. Это 
означает, что элементы списка могут располагаться в любой части памяти, а они связаны только указателями.  

Размер: Размер массива фиксирован, и его нельзя изменить после выделения памяти. В связном списке размер может быть 
изменен в любое время, добавлением или удалением элементов из списка. 

Вставка и удаление: В массиве процесс вставки или удаления элемента может быть затруднен, если это приведет к 
перераспределению памяти. В связном списке элементы могут быть вставлены или удалены просто путем изменения 
указателей.  

Удаление памяти: В массиве освобождение памяти может быть выполнено только после удаления всего массива. В связном 
списке память может быть удалена по мере удаления элементов, которые указывают на нее. 

Поиск элементов: В массиве поиск элемента является быстрее, так как элементы находятся в непрерывном блоке. В 
связном списке поиск может быть затруднен, так как элементы распределены в разных участках памяти, и требуется 
последовательная перестановка, начиная с начала списка.  

Таким образом, в зависимости от задачи, которую необходимо решить, выбирают подходящую структуру данных, либо массив,
либо связный список. 


### Применение различных структур данных python в различных алгоритмах

Структура данных – это способ организации и хранения данных в программе. Они являются важной частью 
программирования и позволяют создавать более эффективные алгоритмы и улучшать быстродействие программы.  
        Рассмотрим несколько примеров применения различных структур данных в алгоритмах:

Структуры данных в Python - это способы организации и хранения данных в программе. В Python доступны следующие 
структуры данных: 

Списки (Lists) - это упорядоченный набор элементов. Списки можно изменять и использовать для хранения любых типов данных.

Кортежи (Tuples) - это упорядоченный набор элементов, но в отличие от списков они не могут быть изменены после создания.

Множества (Sets) - это коллекция уникальных элементов. Элементы множества должны быть хешируемыми.

Словари (Dictionaries) - это набор пар ключ-значение. Ключи должны быть уникальными и хешируемыми.

В Python также доступны специализированные структуры данных, такие как очереди, стеки и древовидные структуры. Чтобы 
использовать эти структуры данных, вы можете использовать библиотеки, такие как collections или heapq. 


#### Списки: 
Списки являются одной из самых используемых структур данных в Python. Они представляют собой упорядоченный 
набор элементов, которые могут быть изменены. Списки могут использоваться для хранения различных типов данных, 
включая числа, строки и другие списки. Например, в алгоритмах поиска и сортировки списки используются для хранения 
значений и их последующей обработки.

Список (List) - это структура данных, которая позволяет хранить последовательность элементов. Основное применение 
списков - организация и хранение информации, упорядочивание и изменение элементов.
Пример использования списка в алгоритме: сортировка пузырьком. В данном случае, мы можем использовать список для 
хранения неупорядоченного набора элементов, а затем, поочередно сравнивать каждый элемент с последующим и менять их 
местами, если это необходимо.

Python использует динамическое управление памятью, что означает, что память присваивается и освобождается 
автоматически во время выполнения программы. 

В Python списки могут быть изменяемыми объектами, и поэтому память, выделенная под список, может увеличиваться и 
уменьшаться в зависимости от того, как его изменяют. 

Когда вы создаете список, Python выделяет память под каждый элемент списка. Если вам нужно создать большой список, 
вы можете снизить использование памяти, используя генераторы списков вместо циклов. 

Кроме того, если вы хотите избежать необходимости создания копии списка, вы можете использовать срезы ([start:end]), 
чтобы получить подмножество списка. 

Некоторые полезные советы для уменьшения использования памяти при работе со списками в Python:

- Используйте генераторы списков вместо циклов, чтобы создавать списки
- Используйте срезы ([start:end]) вместо копирования списков
- Если вы работаете с большими объемами данных, можете использовать сторонние библиотеки, такие как NumPy или Pandas, 
которые оптимизированы для работы с массивами данных. 
- Если вы должны добавить много элементов в список, используйте метод extend вместо append. Метод append может 
привести к созданию большого количества временных списков, что потребует дополнительного использования памяти. 

Независимо от того, как вы используете списки, помните, что Python автоматически управляет памятью, поэтому вы 
можете не беспокоиться о том, что язык повредит системе из-за использования большого количества памяти. Однако 
оптимизация использования памяти может помочь повысить производительность вашей программы, особенно если вы 
работаете с большими объемами данных.   

Пример алгоритма python с использованием списка:
```python
def find_min_element(nums):
    """
    Функция находит наименьший элемент в списке nums и возвращает его
    """
    min_element = nums[0]  # присваиваем первый элемент в списке минимальному элементу
    for num in nums:  # для каждого числа в списке
        if num < min_element:  # если число меньше минимального элемента
            min_element = num  # присваиваем минимальному элементу число
    return min_element  # возвращаем найденный минимальный элемент

my_list = [5, 8, 3, 2, 9, 1]
print(find_min_element(my_list))  # вывод: 1
```
   
### Словари: 
Словари – это структура данных, которая представляет собой неупорядоченный набор пар «ключ-значение». Они 
используются для быстрого доступа к данным с помощью ключа. В алгоритмах, связанных с обработкой больших объемов 
данных, словари могут быть использованы для хранения и обработки данных.  

Каждый раз, когда вы добавляете новый элемент в словарь, вы резервируете часть памяти для хранения этого элемента. 
Также вы можете использовать memory_profiler для измерения использования памяти при работе с вашим словарем. 

Ниже приведены некоторые рекомендации, которые могут помочь вам сэкономить память при работе со словарем.

- Используйте defaultdict, когда это уместно. defaultdict - это подкласс словаря Python, который позволяет задавать 
значение по умолчанию для ключей, которые еще не существуют в словаре. Если вы используете обычный словарь Python и 
пытаетесь получить значение для ключа, которого нет в словаре, вы получите KeyError.  
- Если ваш словарь использует целочисленные ключи, и номера ключей имеют последовательный порядок, вы можете 
использовать список вместо словаря. 
- Если ваш словарь содержит множество ключей, которые являются строками, вы можете использовать OrderedDict.
- Если вы работаете с большими объемами данных, вы можете использовать модуль shelve для более эффективного хранения 
словарей на жестком диске. 

Пример алгоритма python с использованием словаря:
```python
# Создаем словарь с некоторыми значениями
my_dict = {'apple': 10, 'orange': 15, 'banana': 20}

# Выводим все ключи из словаря
print("Все ключи в словаре:")
for key in my_dict:
    print(key)

# Выводим все значения из словаря
print("Все значения в словаре:")
for value in my_dict.values():
    print(value)

# Выводим все пары ключ-значение из словаря
print("Все пары ключ-значение в словаре:")
for key, value in my_dict.items():
    print(key, "->", value)

# Удаляем элемент из словаря
del my_dict['banana']
print("Словарь после удаления элемента:")
print(my_dict)

# Добавляем новый элемент в словарь
my_dict['pear'] = 25
print("Словарь после добавления нового элемента:")
print(my_dict) 

# Все ключи в словаре:
# apple
# orange
# banana
# Все значения в словаре:
# 10
# 15
# 20
# Все пары ключ-значение в словаре:
# apple -> 10
# orange -> 15
# banana -> 20
# Словарь после удаления элемента:
# {'apple': 10, 'orange': 15}
# Словарь после добавления нового элемента:
# {'apple': 10, 'orange': 15, 'pear': 25}
```

### Кортежи: 
Кортежи – это неизменяемые упорядоченные наборы элементов. Кортежи используются для хранения данных, 
которые не должны изменяться в процессе выполнения программы. В алгоритмах, которые имеют дело с множеством данных, 
кортежи могут использоваться как структура для хранения пар значений.  

Кортежи (tuples) в Python хранятся в памяти как неизменяемые объекты. Это означает, что когда вы создаете кортеж, вы 
не можете изменить его содержимое в будущем. 

Кортежи занимают меньше памяти, чем списки, потому что не имеют дополнительных методов для изменения их содержимого. 
Кроме того, кортежи используют только одну ссылку на объект, поэтому они занимают меньше места в памяти. 

Например, если создать список и кортеж с одинаковыми элементами, для кортежа потребуется меньше памяти:

```python
import sys

my_list = [1, 2, 3, 'a', 'b', 'c']
my_tuple = (1, 2, 3, 'a', 'b', 'c')

print(sys.getsizeof(my_list))   # Вывод: 88
print(sys.getsizeof(my_tuple))  # Вывод: 64
```

Как видите, размер кортежа почти на треть меньше, чем размер списка. Это связано с тем, что список имеет 
дополнительные методы (append, extend, insert, remove), которые могут изменить его размер, в то время как кортеж не 
может быть изменен.  

Пример алгоритма python с использованием кортежа:
```python
'''
Этот алгоритм определяет кортеж из нескольких элементов, выводит все элементы кортежа, создает новый кортеж 
с помощью конкатенации, получает элементы кортежа по индексу, считает количество элементов в кортеже и удаляет кортеж. 
'''
# Определяем кортеж из нескольких элементов
tup1 = ('apple', 'banana', 'cherry', 'orange', 'peach')

# Выводим все элементы кортежа
for item in tup1:
    print(item)

# Определяем новый кортеж посредством конкатенации
tup2 = tup1 + ('grape', 'kiwi')

# Выводим новый кортеж
print(tup2)

# Получаем элементы кортежа по индексу
print(tup1[0])
print(tup1[2])

# Считаем количество элементов в кортеже
print(len(tup1))

# Удаляем кортеж
del tup2
```

### Множества: 
Множества – это структуры данных, которые представляют собой неупорядоченные наборы элементов без 
повторений. Множества часто используются в алгоритмах проверки уникальности элементов или для нахождения пересечения 
и объединения множеств.  

В Python множества (set) имеют переменный размер, что означает, что они будут использовать сколько-то памяти в 
зависимости от количества элементов в них. 

Операция создания множества в Python выделяет некоторую память для хранения элементов множества. Эта память не 
освобождается до тех пор, пока множество не будет удалено (удаление происходит при помощи оператора del или после 
того, как переменная-ссылка на множество перестанет указывать на него).  

В общем случае, использование множества в Python не является особенно затратным по памяти. Если множество содержит 
несколько тысяч элементов или меньше, его размер не должен стать проблемой даже на устройствах с ограниченными 
ресурсами.  

Однако, если у вас есть большое количество элементов, то использование множества может привести к большому 
потреблению памяти. В этом случае может помочь использование специализированных структур данных, таких как битовые 
массивы (bit arrays), которые могут использоваться, если вы работаете с множеством значений из определенного 
диапазона, или Bloom filters – наборы хэш-функций, которые могут отвечать на вопрос о том, присутствует ли элемент в 
множестве или нет.    

В любом случае, если вы обнаруживаете, что использование множества приводит к проблемам с памятью, наилучшей 
стратегией может быть оптимизация алгоритма, который вы используете, или переход на более масштабируемые решения, 
использующие например базы данных или хранилища key-value.  


Пример алгоритма python с использованием множества:
```python
'''В этом примере создаются два множества, set1 и set2. Оператор & используется для нахождения пересечения множеств,
 то есть для поиска элементов, которые содержатся в обоих множествах. Результат пересечения сохраняется в 
 переменной intersection, а затем выводится на экран с помощью функции print().
''' 

# Создание множеств
set1 = set([1, 2, 3, 4])
set2 = set([3, 4, 5, 6])

# Использование оператора пересечения
intersection = set1 & set2

# Вывод результата на экран
print("Пересечение множеств:", intersection)
```

Очереди и стеки: Очереди и стеки – это структуры данных, которые используются для организации последовательности 
элементов. Очереди используются для добавления элементов в хвост очереди и извлечения элементов из головы очереди, а 
стеки используются для добавления и извлечения элементов только с одного конца. Очереди и стеки часто используются в 
алгоритмах поиска и обхода графов, например в алгоритме поиска в глубину. 

Стек (Stack) - это структура данных, которая позволяет хранить элементы в порядке "последний вошел - первый вышел". 
Стеки используются в алгоритмах, где необходимо сохранить последовательность выполнения операций и выполнить их в 
обратном порядке.
Пример использования стека в алгоритме: обход дерева в глубину. В данном случае, мы используем стек, чтобы 
сохранить последовательность посещения узлов дерева и выполнить их в обратном порядке. Такой подход позволяет 
обойти все узлы дерева и выполнить необходимые операции.

Очередь (Queue) - это структура данных, которая позволяет хранить элементы в порядке "первый вошел - первый вышел". 
Очереди используются в алгоритмах, где необходимо сохранить последовательность выполнения операций и выполнить их в 
порядке очереди.
Пример использования очереди в алгоритме: алгоритм обхода в ширину в графе. В данном случае, мы используем очередь, 
чтобы сохранить последовательность посещения вершин графа и выполнить их в порядке очереди. Это позволяет обойти все 
вершины графа и выполнить необходимые операции.  

Массив (Array) - это структура данных, которая позволяет хранить несколько элементов одного типа. Массивы 
используются для организации информации, а также для улучшения быстродействия при доступе к элементам.
Пример использования массива в алгоритме: двоичный поиск. Двоичный поиск - это алгоритм поиска элемента в 
упорядоченном массиве. Он работает быстрее, чем последовательный поиск, потому что использует принцип деления 
массива на половинки и сравнения элемента с значением середины. Таким образом, массив позволяет быстро осуществить 
доступ к элементам и выполнить необходимые операции.









  