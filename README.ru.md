<p>
  <img  src="https://img.shields.io/github/stars/BEPb/Programmer_Competency_Matrix" />
  <img src="https://img.shields.io/github/contributors/BEPb/Programmer_Competency_Matrix" />
  <img src="https://img.shields.io/github/last-commit/BEPb/Programmer_Competency_Matrix" />
  <img src="https://visitor-badge.laobi.icu/badge?page_id=BEPb.Programmer_Competency_Matrix" />
  <img src="https://img.shields.io/github/languages/count/BEPb/Programmer_Competency_Matrix" />
  <img src="https://img.shields.io/github/languages/top/BEPb/Programmer_Competency_Matrix" />
  <img src="https://img.shields.io/badge/license-MIT-blue.svg?color=f64152" />
  <img  src="https://img.shields.io/github/issues/BEPb/Programmer_Competency_Matrix" />
  <img  src="https://img.shields.io/github/issues-pr/BEPb/Programmer_Competency_Matrix" />
</p>
<div align="center">


<img src="./art/logo.png" alt="Bot logo" width="400" height="300">

# Матрица компетентности программиста

</div>

Прочитать версию на другом языке: [English](README.md)

## Всем привет. 

Сегодня 13 марта 2023 года, и так уж получилось что более 3 лет я активно изучае программирование на питоне а так 
же науку о данных. Через половину года заканчивается контракт и я решил - пришло время смены деятельности из 
радиоинженера в специалиста машинного обучения. Но как оценить себя, как показать будущему работодателю что я знаю, 
умею, как развиваюсь??? Разделяй и властвуй (лат. divide et impera) - глосит максима римского сената, подойдем 
системно к ответу на заданный вопрос. Разделим все составляющие моих знаний специалиста и оценим их используюя 
матрицу компетентности. 

разумеется я не стал изобретать велосипед и взял уже готовую матрицу (наиболее рапроспространенный вариант предложен 
Сидзин Джозефом [вот](https://sijinjoseph.netlify.app/programmer-competency-matrix/)) и честно отвечал на указанные вопросы, ответ старательно складывал в отдельные файлы.


#### В процессе...


<details>
           <summary>Знания данных, алгоритмы, ПО</summary>
 
- [ ] **Структуры данных**
   - [x] [Уровень 0](#Разница-между-массивом-и-связным-списком) - Не знает разницы между массивом и связанным списком
   - [x] [Уровень 1](#Применение-различных-структур-данных-python-в-различных-алгоритмах) - Способность объяснять и 
     использовать массивы, связанные списки, словари и т. д. в практических задачах программирования 
   - [x] Уровень 2 - Знает компромиссы между пространством и временем для основных структур данных, Массивы и связанные списки, Способен объяснить
     как хеш-таблицы могут быть реализованы и могут обрабатывать коллизии, приоритетные очереди и способы их реализации и т. д.
   - [x] Уровень 3 - Знание расширенных структур данных, таких как B-деревья, биномиальные кучи и кучи Фибоначчи, деревья AVL/Red Black,
     Развернуть деревья, списки пропусков, попытки и т. д.

- [ ] **Алгоритмы**
   - [x] Уровень 0 - Невозможно найти среднее число чисел в массиве (Сложно поверить, но я проводил собеседования с такими кандидатами)
   - [x] Уровень 1 - Базовые алгоритмы сортировки, поиска и обхода структуры данных и извлечения
   - [x] Уровень 2 - Дерево, График, простые жадные алгоритмы и алгоритмы "разделяй и властвуй", способен понимать
     актуальность уровней этой матрицы.
   - [ ] Уровень 3 - Способность распознавать и кодировать решения динамического программирования, хорошее знание графовых алгоритмов,
     хорошее знание алгоритмов численных вычислений, способность идентифицировать проблемы NP и т. д.
    
- [ ] **Системное программирование**
   - [x] Уровень 0 - Не знает, что такое компилятор, компоновщик или интерпретатор
   - [x] Уровень 1 - Базовое понимание компиляторов, компоновщиков и интерпретаторов. Понимает, что такое ассемблерный код и
     как все работает на аппаратном уровне. Некоторые знания о виртуальной памяти и подкачке.
   - [ ] Уровень 2 — понимание режима ядра и пользовательского режима, многопоточности, примитивов синхронизации и того, как они работают.
         реализован, способен читать ассемблерный код. Понимает, как работают сети, понимает сетевые протоколы и
         программирование на уровне сокетов.
   - [ ] Уровень 3 - Понимает весь программный стек, оборудование (ЦП + Память + Кэш +
         прерывания + микрокод), бинарный код, сборка, статическая и динамическая компоновка, компиляция, интерпретация, JIT
         компиляция, сборка мусора, куча, стек, адресация памяти...

</details>



### Разница между массивом и связным списком 

Разница между массивом и связным списком заключается в том, что массив представляет собой статическую структуру 
данных, а связный список является динамической структурой данных. 

Массив и связный список - это две основные структуры данных, используемые для хранения и управления набором объектов.
Они имеют следующие отличия: 

Память: Массив в основном занимает непрерывный блок памяти, где каждый элемент имеет свой индекс. Связный список 
использует "узлы", каждый из которых содержит указатель на следующий элемент списка и данные этого элемента. Это 
означает, что элементы списка могут располагаться в любой части памяти, а они связаны только указателями.  

Размер: Размер массива фиксирован, и его нельзя изменить после выделения памяти. В связном списке размер может быть 
изменен в любое время, добавлением или удалением элементов из списка. 

Вставка и удаление: В массиве процесс вставки или удаления элемента может быть затруднен, если это приведет к 
перераспределению памяти. В связном списке элементы могут быть вставлены или удалены просто путем изменения 
указателей.  

Удаление памяти: В массиве освобождение памяти может быть выполнено только после удаления всего массива. В связном 
списке память может быть удалена по мере удаления элементов, которые указывают на нее. 

Поиск элементов: В массиве поиск элемента является быстрее, так как элементы находятся в непрерывном блоке. В 
связном списке поиск может быть затруднен, так как элементы распределены в разных участках памяти, и требуется 
последовательная перестановка, начиная с начала списка.  

Таким образом, в зависимости от задачи, которую необходимо решить, выбирают подходящую структуру данных, либо массив,
либо связный список. 


### Применение различных структур данных python в различных алгоритмах

Структура данных – это способ организации и хранения данных в программе. Они являются важной частью 
программирования и позволяют создавать более эффективные алгоритмы и улучшать быстродействие программы.  
        Рассмотрим несколько примеров применения различных структур данных в алгоритмах:

Списки: Списки являются одной из самых используемых структур данных в Python. Они представляют собой упорядоченный 
набор элементов, которые могут быть изменены. Списки могут использоваться для хранения различных типов данных, 
включая числа, строки и другие списки. Например, в алгоритмах поиска и сортировки списки используются для хранения 
значений и их последующей обработки.
Список (List) - это структура данных, которая позволяет хранить последовательность элементов. Основное применение 
списков - организация и хранение информации, упорядочивание и изменение элементов.
Пример использования списка в алгоритме: сортировка пузырьком. В данном случае, мы можем использовать список для 
хранения неупорядоченного набора элементов, а затем, поочередно сравнивать каждый элемент с последующим и менять их 
местами, если это необходимо.
   
Словари: Словари – это структура данных, которая представляет собой неупорядоченный набор пар «ключ-значение». Они 
используются для быстрого доступа к данным с помощью ключа. В алгоритмах, связанных с обработкой больших объемов 
данных, словари могут быть использованы для хранения и обработки данных.  

Кортежи: Кортежи – это неизменяемые упорядоченные наборы элементов. Кортежи используются для хранения данных, 
которые не должны изменяться в процессе выполнения программы. В алгоритмах, которые имеют дело с множеством данных, 
кортежи могут использоваться как структура для хранения пар значений.  

Множества: Множества – это структуры данных, которые представляют собой неупорядоченные наборы элементов без 
повторений. Множества часто используются в алгоритмах проверки уникальности элементов или для нахождения пересечения 
и объединения множеств.  

Очереди и стеки: Очереди и стеки – это структуры данных, которые используются для организации последовательности 
элементов. Очереди используются для добавления элементов в хвост очереди и извлечения элементов из головы очереди, а 
стеки используются для добавления и извлечения элементов только с одного конца. Очереди и стеки часто используются в 
алгоритмах поиска и обхода графов, например в алгоритме поиска в глубину. 

Стек (Stack) - это структура данных, которая позволяет хранить элементы в порядке "последний вошел - первый вышел". 
Стеки используются в алгоритмах, где необходимо сохранить последовательность выполнения операций и выполнить их в 
обратном порядке.
Пример использования стека в алгоритме: обход дерева в глубину. В данном случае, мы используем стек, чтобы 
сохранить последовательность посещения узлов дерева и выполнить их в обратном порядке. Такой подход позволяет 
обойти все узлы дерева и выполнить необходимые операции.

Очередь (Queue) - это структура данных, которая позволяет хранить элементы в порядке "первый вошел - первый вышел". 
Очереди используются в алгоритмах, где необходимо сохранить последовательность выполнения операций и выполнить их в 
порядке очереди.
Пример использования очереди в алгоритме: алгоритм обхода в ширину в графе. В данном случае, мы используем очередь, 
чтобы сохранить последовательность посещения вершин графа и выполнить их в порядке очереди. Это позволяет обойти все 
вершины графа и выполнить необходимые операции.  

Массив (Array) - это структура данных, которая позволяет хранить несколько элементов одного типа. Массивы 
используются для организации информации, а также для улучшения быстродействия при доступе к элементам.
Пример использования массива в алгоритме: двоичный поиск. Двоичный поиск - это алгоритм поиска элемента в 
упорядоченном массиве. Он работает быстрее, чем последовательный поиск, потому что использует принцип деления 
массива на половинки и сравнения элемента с значением середины. Таким образом, массив позволяет быстро осуществить 
доступ к элементам и выполнить необходимые операции.









  