<p>
  <img  src="https://img.shields.io/github/stars/BEPb/Programmer_Competency_Matrix" />
  <img src="https://img.shields.io/github/contributors/BEPb/Programmer_Competency_Matrix" />
  <img src="https://img.shields.io/github/last-commit/BEPb/Programmer_Competency_Matrix" />
  <img src="https://visitor-badge.laobi.icu/badge?page_id=BEPb.Programmer_Competency_Matrix" />
  <img src="https://img.shields.io/github/languages/count/BEPb/Programmer_Competency_Matrix" />
  <img src="https://img.shields.io/github/languages/top/BEPb/Programmer_Competency_Matrix" />
  <img src="https://img.shields.io/badge/license-MIT-blue.svg?color=f64152" />
  <img  src="https://img.shields.io/github/issues/BEPb/Programmer_Competency_Matrix" />
  <img  src="https://img.shields.io/github/issues-pr/BEPb/Programmer_Competency_Matrix" />
</p>
<div align="center">


<img src="./art/logo.png" alt="Bot logo" width="400" height="300">

# Матрица компетентности программиста

</div>

Прочитать версию на другом языке: [English](README.md)

## Всем привет. 

Сегодня 13 марта 2023 года, и так уж получилось что более 3 лет я активно изучае программирование на питоне а так 
же науку о данных. Через половину года заканчивается контракт и я решил - пришло время смены деятельности из 
радиоинженера в специалиста машинного обучения. Но как оценить себя, как показать будущему работодателю что я знаю, 
умею, как развиваюсь??? Разделяй и властвуй (лат. divide et impera) - глосит максима римского сената, подойдем 
системно к ответу на заданный вопрос. Разделим все составляющие моих знаний специалиста и оценим их используюя 
матрицу компетентности. 

разумеется я не стал изобретать велосипед и взял уже готовую матрицу (наиболее рапроспространенный вариант предложен 
Сидзин Джозефом [вот](https://sijinjoseph.netlify.app/programmer-competency-matrix/)) и честно отвечал на указанные вопросы, ответ старательно складывал в отдельные файлы.


#### В процессе...


<details>
           <summary>Знания данных, алгоритмы, ПО</summary>
 
- [ ] **Структуры данных**
   - [x] [Уровень 0](#Разница-между-массивом-и-связным-списком) - Не знает разницы между массивом и связанным списком
   - [x] [Уровень 1](#Применение-различных-структур-данных-python-в-различных-алгоритмах) - Способность объяснять и 
     использовать массивы, связанные списки, словари и т. д. в практических задачах программирования 
   - [x] [Уровень 2](#Плюсы-и-минусы-использования-базовых-структур-данных-Python) - Понимает плюсы и минусы 
     использования тех или иных базовых структур данных (размер памяти, 
     время выполнения операций с данными, в чем разница между массивами и связными списками в этом плане).
     Может объяснить как реализовать хэш-таблицы и как обработать коллизии. Приоритетные очереди и способы их 
     реализации и т. д.
   - [x] [Уровень 3](#Знание-расширенных-структур-данных) - Знание сложных структур данных, таких как B-дерево, 
     Биномиальная куча и куча Фибоначчи, АВЛ-дерево, Красно-чёрное дерево, Косое дерево, Список с пропусками, 
     TRIE-структуры и т.д. 

- [ ] **Алгоритмы**
   - [x] Уровень 0 - Невозможно найти среднее число чисел в массиве (Сложно поверить, но я проводил собеседования с такими кандидатами)
   - [x] Уровень 1 - Базовые алгоритмы сортировки, поиска и обхода структуры данных и извлечения
   - [x] Уровень 2 - Дерево, График, простые жадные алгоритмы и алгоритмы "разделяй и властвуй", способен понимать
     актуальность уровней этой матрицы.
   - [ ] Уровень 3 - Способность распознавать и кодировать решения динамического программирования, хорошее знание графовых алгоритмов,
     хорошее знание алгоритмов численных вычислений, способность идентифицировать проблемы NP и т. д.
    
- [ ] **Системное программирование**
   - [x] Уровень 0 - Не знает, что такое компилятор, компоновщик или интерпретатор
   - [x] Уровень 1 - Базовое понимание компиляторов, компоновщиков и интерпретаторов. Понимает, что такое ассемблерный код и
     как все работает на аппаратном уровне. Некоторые знания о виртуальной памяти и подкачке.
   - [ ] Уровень 2 — понимание режима ядра и пользовательского режима, многопоточности, примитивов синхронизации и того, как они работают.
         реализован, способен читать ассемблерный код. Понимает, как работают сети, понимает сетевые протоколы и
         программирование на уровне сокетов.
   - [ ] Уровень 3 - Понимает весь программный стек, оборудование (ЦП + Память + Кэш +
         прерывания + микрокод), бинарный код, сборка, статическая и динамическая компоновка, компиляция, интерпретация, JIT
         компиляция, сборка мусора, куча, стек, адресация памяти...

</details>



### Разница между массивом и связным списком 

Разница между массивом и связным списком заключается в том, что массив представляет собой статическую структуру 
данных, а связный список является динамической структурой данных. 

Массив и связный список - это две основные структуры данных, используемые для хранения и управления набором объектов.
Они имеют следующие отличия: 

Память: Массив в основном занимает непрерывный блок памяти, где каждый элемент имеет свой индекс. Связный список 
использует "узлы", каждый из которых содержит указатель на следующий элемент списка и данные этого элемента. Это 
означает, что элементы списка могут располагаться в любой части памяти, а они связаны только указателями.  

Размер: Размер массива фиксирован, и его нельзя изменить после выделения памяти. В связном списке размер может быть 
изменен в любое время, добавлением или удалением элементов из списка. 

Вставка и удаление: В массиве процесс вставки или удаления элемента может быть затруднен, если это приведет к 
перераспределению памяти. В связном списке элементы могут быть вставлены или удалены просто путем изменения 
указателей.  

Удаление памяти: В массиве освобождение памяти может быть выполнено только после удаления всего массива. В связном 
списке память может быть удалена по мере удаления элементов, которые указывают на нее. 

Поиск элементов: В массиве поиск элемента является быстрее, так как элементы находятся в непрерывном блоке. В 
связном списке поиск может быть затруднен, так как элементы распределены в разных участках памяти, и требуется 
последовательная перестановка, начиная с начала списка.  

Таким образом, в зависимости от задачи, которую необходимо решить, выбирают подходящую структуру данных, либо массив,
либо связный список. 


### Применение различных структур данных python в различных алгоритмах

Структура данных – это способ организации и хранения данных в программе. Они являются важной частью 
программирования и позволяют создавать более эффективные алгоритмы и улучшать быстродействие программы.  
        Рассмотрим несколько примеров применения различных структур данных в алгоритмах:

Структуры данных в Python - это способы организации и хранения данных в программе. В Python доступны следующие 
структуры данных: 

Списки (Lists) - это упорядоченный набор элементов. Списки можно изменять и использовать для хранения любых типов данных.

Кортежи (Tuples) - это упорядоченный набор элементов, но в отличие от списков они не могут быть изменены после создания.

Множества (Sets) - это коллекция уникальных элементов. Элементы множества должны быть хешируемыми.

Словари (Dictionaries) - это набор пар ключ-значение. Ключи должны быть уникальными и хешируемыми.

В Python также доступны специализированные структуры данных, такие как очереди, стеки и древовидные структуры. Чтобы 
использовать эти структуры данных, вы можете использовать библиотеки, такие как collections или heapq. 


#### Списки: 
Списки являются одной из самых используемых структур данных в Python. Они представляют собой упорядоченный 
набор элементов, которые могут быть изменены. Списки могут использоваться для хранения различных типов данных, 
включая числа, строки и другие списки. Например, в алгоритмах поиска и сортировки списки используются для хранения 
значений и их последующей обработки.

Список (List) - это структура данных, которая позволяет хранить последовательность элементов. Основное применение 
списков - организация и хранение информации, упорядочивание и изменение элементов.
Пример использования списка в алгоритме: сортировка пузырьком. В данном случае, мы можем использовать список для 
хранения неупорядоченного набора элементов, а затем, поочередно сравнивать каждый элемент с последующим и менять их 
местами, если это необходимо.

Python использует динамическое управление памятью, что означает, что память присваивается и освобождается 
автоматически во время выполнения программы. 

В Python списки могут быть изменяемыми объектами, и поэтому память, выделенная под список, может увеличиваться и 
уменьшаться в зависимости от того, как его изменяют. 

Когда вы создаете список, Python выделяет память под каждый элемент списка. Если вам нужно создать большой список, 
вы можете снизить использование памяти, используя генераторы списков вместо циклов. 

Кроме того, если вы хотите избежать необходимости создания копии списка, вы можете использовать срезы ([start:end]), 
чтобы получить подмножество списка. 

Некоторые полезные советы для уменьшения использования памяти при работе со списками в Python:

- Используйте генераторы списков вместо циклов, чтобы создавать списки
- Используйте срезы ([start:end]) вместо копирования списков
- Если вы работаете с большими объемами данных, можете использовать сторонние библиотеки, такие как NumPy или Pandas, 
которые оптимизированы для работы с массивами данных. 
- Если вы должны добавить много элементов в список, используйте метод extend вместо append. Метод append может 
привести к созданию большого количества временных списков, что потребует дополнительного использования памяти. 

Независимо от того, как вы используете списки, помните, что Python автоматически управляет памятью, поэтому вы 
можете не беспокоиться о том, что язык повредит системе из-за использования большого количества памяти. Однако 
оптимизация использования памяти может помочь повысить производительность вашей программы, особенно если вы 
работаете с большими объемами данных.   

Пример алгоритма python с использованием списка:
```python
def find_min_element(nums):
    """
    Функция находит наименьший элемент в списке nums и возвращает его
    """
    min_element = nums[0]  # присваиваем первый элемент в списке минимальному элементу
    for num in nums:  # для каждого числа в списке
        if num < min_element:  # если число меньше минимального элемента
            min_element = num  # присваиваем минимальному элементу число
    return min_element  # возвращаем найденный минимальный элемент

my_list = [5, 8, 3, 2, 9, 1]
print(find_min_element(my_list))  # вывод: 1
```
   
#### Словари: 
Словари – это структура данных, которая представляет собой неупорядоченный набор пар «ключ-значение». Они 
используются для быстрого доступа к данным с помощью ключа. В алгоритмах, связанных с обработкой больших объемов 
данных, словари могут быть использованы для хранения и обработки данных.  

Каждый раз, когда вы добавляете новый элемент в словарь, вы резервируете часть памяти для хранения этого элемента. 
Также вы можете использовать memory_profiler для измерения использования памяти при работе с вашим словарем. 

Ниже приведены некоторые рекомендации, которые могут помочь вам сэкономить память при работе со словарем.

- Используйте defaultdict, когда это уместно. defaultdict - это подкласс словаря Python, который позволяет задавать 
значение по умолчанию для ключей, которые еще не существуют в словаре. Если вы используете обычный словарь Python и 
пытаетесь получить значение для ключа, которого нет в словаре, вы получите KeyError.  
- Если ваш словарь использует целочисленные ключи, и номера ключей имеют последовательный порядок, вы можете 
использовать список вместо словаря. 
- Если ваш словарь содержит множество ключей, которые являются строками, вы можете использовать OrderedDict.
- Если вы работаете с большими объемами данных, вы можете использовать модуль shelve для более эффективного хранения 
словарей на жестком диске. 

Пример алгоритма python с использованием словаря:
```python
# Создаем словарь с некоторыми значениями
my_dict = {'apple': 10, 'orange': 15, 'banana': 20}

# Выводим все ключи из словаря
print("Все ключи в словаре:")
for key in my_dict:
    print(key)

# Выводим все значения из словаря
print("Все значения в словаре:")
for value in my_dict.values():
    print(value)

# Выводим все пары ключ-значение из словаря
print("Все пары ключ-значение в словаре:")
for key, value in my_dict.items():
    print(key, "->", value)

# Удаляем элемент из словаря
del my_dict['banana']
print("Словарь после удаления элемента:")
print(my_dict)

# Добавляем новый элемент в словарь
my_dict['pear'] = 25
print("Словарь после добавления нового элемента:")
print(my_dict) 

# Все ключи в словаре:
# apple
# orange
# banana
# Все значения в словаре:
# 10
# 15
# 20
# Все пары ключ-значение в словаре:
# apple -> 10
# orange -> 15
# banana -> 20
# Словарь после удаления элемента:
# {'apple': 10, 'orange': 15}
# Словарь после добавления нового элемента:
# {'apple': 10, 'orange': 15, 'pear': 25}
```

#### Кортежи: 
Кортежи – это неизменяемые упорядоченные наборы элементов. Кортежи используются для хранения данных, 
которые не должны изменяться в процессе выполнения программы. В алгоритмах, которые имеют дело с множеством данных, 
кортежи могут использоваться как структура для хранения пар значений.  

Кортежи (tuples) в Python хранятся в памяти как неизменяемые объекты. Это означает, что когда вы создаете кортеж, вы 
не можете изменить его содержимое в будущем. 

Кортежи занимают меньше памяти, чем списки, потому что не имеют дополнительных методов для изменения их содержимого. 
Кроме того, кортежи используют только одну ссылку на объект, поэтому они занимают меньше места в памяти. 

Например, если создать список и кортеж с одинаковыми элементами, для кортежа потребуется меньше памяти:

```python
import sys

my_list = [1, 2, 3, 'a', 'b', 'c']
my_tuple = (1, 2, 3, 'a', 'b', 'c')

print(sys.getsizeof(my_list))   # Вывод: 88
print(sys.getsizeof(my_tuple))  # Вывод: 64
```

Как видите, размер кортежа почти на треть меньше, чем размер списка. Это связано с тем, что список имеет 
дополнительные методы (append, extend, insert, remove), которые могут изменить его размер, в то время как кортеж не 
может быть изменен.  

Пример алгоритма python с использованием кортежа:
```python
'''
Этот алгоритм определяет кортеж из нескольких элементов, выводит все элементы кортежа, создает новый кортеж 
с помощью конкатенации, получает элементы кортежа по индексу, считает количество элементов в кортеже и удаляет кортеж. 
'''
# Определяем кортеж из нескольких элементов
tup1 = ('apple', 'banana', 'cherry', 'orange', 'peach')

# Выводим все элементы кортежа
for item in tup1:
    print(item)

# Определяем новый кортеж посредством конкатенации
tup2 = tup1 + ('grape', 'kiwi')

# Выводим новый кортеж
print(tup2)

# Получаем элементы кортежа по индексу
print(tup1[0])
print(tup1[2])

# Считаем количество элементов в кортеже
print(len(tup1))

# Удаляем кортеж
del tup2
```

#### Множества: 
Множества – это структуры данных, которые представляют собой неупорядоченные наборы элементов без 
повторений. Множества часто используются в алгоритмах проверки уникальности элементов или для нахождения пересечения 
и объединения множеств.  

В Python множества (set) имеют переменный размер, что означает, что они будут использовать сколько-то памяти в 
зависимости от количества элементов в них. 

Операция создания множества в Python выделяет некоторую память для хранения элементов множества. Эта память не 
освобождается до тех пор, пока множество не будет удалено (удаление происходит при помощи оператора del или после 
того, как переменная-ссылка на множество перестанет указывать на него).  

В общем случае, использование множества в Python не является особенно затратным по памяти. Если множество содержит 
несколько тысяч элементов или меньше, его размер не должен стать проблемой даже на устройствах с ограниченными 
ресурсами.  

Однако, если у вас есть большое количество элементов, то использование множества может привести к большому 
потреблению памяти. В этом случае может помочь использование специализированных структур данных, таких как битовые 
массивы (bit arrays), которые могут использоваться, если вы работаете с множеством значений из определенного 
диапазона, или Bloom filters – наборы хэш-функций, которые могут отвечать на вопрос о том, присутствует ли элемент в 
множестве или нет.    

В любом случае, если вы обнаруживаете, что использование множества приводит к проблемам с памятью, наилучшей 
стратегией может быть оптимизация алгоритма, который вы используете, или переход на более масштабируемые решения, 
использующие например базы данных или хранилища key-value.  


Пример алгоритма python с использованием множества:
```python
'''В этом примере создаются два множества, set1 и set2. Оператор & используется для нахождения пересечения множеств,
 то есть для поиска элементов, которые содержатся в обоих множествах. Результат пересечения сохраняется в 
 переменной intersection, а затем выводится на экран с помощью функции print().
''' 

# Создание множеств
set1 = set([1, 2, 3, 4])
set2 = set([3, 4, 5, 6])

# Использование оператора пересечения
intersection = set1 & set2

# Вывод результата на экран
print("Пересечение множеств:", intersection)
```

#### Очереди и стеки: 
Очереди и стеки – это структуры данных, которые используются для организации последовательности 
элементов. Очереди используются для добавления элементов в хвост очереди и извлечения элементов из головы очереди, а 
стеки используются для добавления и извлечения элементов только с одного конца. Очереди и стеки часто используются в 
алгоритмах поиска и обхода графов, например в алгоритме поиска в глубину. 

Стек (Stack) - это структура данных, которая позволяет хранить элементы в порядке "последний вошел - первый вышел". 
Стеки используются в алгоритмах, где необходимо сохранить последовательность выполнения операций и выполнить их в 
обратном порядке.
Пример использования стека в алгоритме: обход дерева в глубину. В данном случае, мы используем стек, чтобы 
сохранить последовательность посещения узлов дерева и выполнить их в обратном порядке. Такой подход позволяет 
обойти все узлы дерева и выполнить необходимые операции.

Очередь (Queue) - это структура данных, которая позволяет хранить элементы в порядке "первый вошел - первый вышел". 
Очереди используются в алгоритмах, где необходимо сохранить последовательность выполнения операций и выполнить их в 
порядке очереди.
Пример использования очереди в алгоритме: алгоритм обхода в ширину в графе. В данном случае, мы используем очередь, 
чтобы сохранить последовательность посещения вершин графа и выполнить их в порядке очереди. Это позволяет обойти все 
вершины графа и выполнить необходимые операции.  

Массив (Array) - это структура данных, которая позволяет хранить несколько элементов одного типа. Массивы 
используются для организации информации, а также для улучшения быстродействия при доступе к элементам.
Пример использования массива в алгоритме: двоичный поиск. Двоичный поиск - это алгоритм поиска элемента в 
упорядоченном массиве. Он работает быстрее, чем последовательный поиск, потому что использует принцип деления 
массива на половинки и сравнения элемента с значением середины. Таким образом, массив позволяет быстро осуществить 
доступ к элементам и выполнить необходимые операции.

### Плюсы и минусы использования базовых структур данных Python
Плюсы использования базовых структур данных Python:
- Удобство использования - базовые структуры данных в Python легко создаются и манипулируются. Например, чтобы создать 
список, достаточно указать элементы в квадратных скобках. 
- Высокая производительность - базовые структуры данных в Python имеют высокую скорость работы, что позволяет быстро 
обрабатывать большие объемы данных. 
- Разнообразие структур данных - Python поддерживает множество базовых структур данных, включая списки, кортежи, 
словари и множества, что позволяет выбрать наиболее подходящую структуру данных для конкретной задачи. 
- Широкое использование - базовые структуры данных Python используются в различных областях, от научных исследований 
до веб-разработки. 

Минусы использования базовых структур данных Python:
- Низкая эффективность работы с большими объемами данных - при работе с очень большими объемами данных, базовые структуры данных Python могут стать медленными, и потребуется использовать специализированные библиотеки для обработки данных.
- Ограниченная функциональность - базовые структуры данных Python имеют ограниченную функциональность по сравнению со специализированными структурами данных, такими как массивы или деревья.
- Нет поддержки многопоточности - базовые структуры данных Python не могут использоваться эффективно для многопоточных приложений и требуют специализированных библиотек.
- Нарушение инкапсуляции - базовые структуры данных Python не имеют инкапсулированных методов, что может привести к 
ошибкам при работе с ними. 

#### Что такое хэш-таблицы и как реализовать хэш-таблицы в Python
Хэш-таблица - это структура данных, которая позволяет эффективно хранить и получать значения по ключу. Она 
использует хэш-функцию для преобразования ключа в индекс массива. Каждый индекс в массиве связан с некоторым 
значением. Хэш-таблица позволяет быстро находить значения по ключу, используя только одну операцию доступа к памяти.   
В Python хэш-таблица реализуется в виде словаря (dict). Внутри словаря данные хранятся в виде пар ключ-значение, где 
ключи являются уникальными хэш-значениями, а значения представляют собой соответствующие объекты. 

При добавлении нового элемента в словарь, ключ этого элемента вычисляется с помощью хэш-функции, которая преобразует 
произвольную строку или число в уникальное число фиксированной длины. Затем этот ключ используется для индексации 
соответствующего места в памяти, где хранится значение.  

Для решения коллизий, т.е. ситуаций, когда два разных ключа имеют одинаковое хэш-значение, Python использует метод 
цепочек. При этом для каждого слота в таблице выделяется связный список, в который добавляются элементы с 
одинаковыми ключами хэш-функции. Когда количество элементов в списке становится слишком большим, Python 
автоматически перестраивает таблицу, увеличивая ее размер.   

Таким образом, хэш-таблица в Python реализована как динамическая структура данных, позволяющая эффективно хранить и 
быстро находить элементы по ключу. 

```python
# В Python реализация хэш-таблицы доступна в виде словарей (dict). Для добавления элемента в словарь используется 
# следующий синтаксис: 

my_dict = {}
my_dict[key] = value


# Для получения значения по ключу нужно использовать следующий синтаксис:
my_dict[key]
```

Python также позволяет использовать пользовательские классы в качестве ключей в словарях, если эти классы реализуют 
методы __hash__() и __eq__(). 

Подробный пример реализации хэш-таблицы в Python:
  
```python
class HashTable:  # Создаём класс HashTable
    def __init__(self):  # Определяем метод __init__ - инициализация или сборка класса
        self.size = 11  # определяем размер хэш-таблицы self.size
        self.slots = [None] * self.size  # массив для ключей self.slots Для начальной инициализации используем None.
        self.data = [None] * self.size  # массив для значений self.data Для начальной инициализации используем None.

    def put(self, key, data):  # Определяем метод put. В нём передаем ключ key и значение data.
        '''Определяем хэш-значение ключа hash_value с помощью метода self.hash_function.
          '''
        hash_value = self.hash_function(key, len(self.slots))
        
        ''' Если на данном хэш-значении в массиве self.slots пусто, 
        то заполняем соответствующие места ключа и значения новыми значениями.'''
        if self.slots[hash_value] is None:
            self.slots[hash_value] = key
            self.data[hash_value] = data
        else:
            '''Если на данном хэш-значении уже есть ключ, то заменяем старое значение на новое.'''
            if self.slots[hash_value] == key:
                self.data[hash_value] = data  # replace
            else:
                '''Если на данном хэш-значении пусто и 
                это не первоначальная итерация, то находим следующее пустое место в хэш-таблице с помощью метода self.rehash,
                который возвращает новое хэш-значение на основе старого (линейное пробирование).'''
                next_slot = self.rehash(hash_value, len(self.slots))
                while self.slots[next_slot] is not None and self.slots[next_slot] != key:  
                    next_slot = self.rehash(next_slot, len(self.slots))
                
                ''' Если нашёлся свободный слот, то записываем ключ и значение на него.'''
                if self.slots[next_slot] is None:
                    self.slots[next_slot] = key
                    self.data[next_slot] = data
                else:
                    self.data[next_slot] = data  # replace

    def get(self, key):
        '''Определяем метод get. В нём передаем ключ key. Определяем начальное позицию start_slot в таблице с 
        помощью метода self.hash_function. 
           
        '''
        start_slot = self.hash_function(key, len(self.slots))

        # Создаем переменную для значения data, а также переменные для управления циклом: stop, found и position.
        data = None
        stop = False
        found = False
        position = start_slot
        while self.slots[position] is not None and not found and not stop:
            '''Стартуем цикл. Если на текущей позиции в таблице находится нужный ключ, то 
            записываем соответствующее значение в переменную data и устанавливаем флаг found в значение True.'''
            if self.slots[position] == key:
                found = True
                data = self.data[position]
            else:
                '''Если на  текущей позиции в таблице находится не нужный ключ, то переходим на следующую позицию с 
                помощью метода self.rehash.'''
                position = self.rehash(position, len(self.slots))
                if position == start_slot: 
                    '''Если дошли до начальной позиции, то выходим из цикла. Возвращаем значение data, которое либо 
                    осталось None, либо содержит нужное значение.'''
                    stop = True
        return data

    def hash_function(self, key, size):
        '''Определяем метод hash_function, который принимает ключ key и размер хэш-таблицы size. Возвращает остаток 
        от деления ключа на размер таблицы.
        '''
        return key % size

    def rehash(self, old_hash, size):
        '''Определяем метод rehash, который принимает старый хэш old_hash и размер таблицы size. Возвращает новый хэш на основе 
        текущего, увеличенного на единицу. Если новый хэш больше размера таблицы, то он сбрасывается на ноль. 
        Применяется линейное пробирование. 
        '''
        return (old_hash + 1) % size
```

Пример реализации хэш-таблицы в Python:
```python
'''
Класс HashTable имеет методы insert, search и delete, которые соответственно позволяют добавлять элементы в 
хэш-таблицу, искать их и удалять. Хэш-функция просто берет остаток от деления ключа на размер таблицы. Если в один 
слот попадает несколько элементов, они хранятся в виде кортежа (ключ, значение). Если ключ уже есть в таблице при 
добавлении, то его значение заменяется новым. При поиске элемента, хэш-таблица вычисляет для него значение 
хэш-функции и итерируется по соответствующему слоту, пока не находится элемент с нужным ключом. При удалении 
элемента происходит аналогичный поиск, и если элемент найден, он удаляется из слота.
'''
class HashTable:
    def __init__(self, size=10):
        self.size = size
        self.table = [[] for _ in range(self.size)]

    def _hash_function(self, key):
        return key % self.size

    def insert(self, key, value):
        hash_value = self._hash_function(key)
        slot = self.table[hash_value]
        for i, (k, v) in enumerate(slot):
            if k == key:
                slot[i] = (key, value)
                break
        else:
            slot.append((key, value))

    def search(self, key):
        hash_value = self._hash_function(key)
        slot = self.table[hash_value]
        for k, v in slot:
            if k == key:
                return v
        raise KeyError(key)

    def delete(self, key):
        hash_value = self._hash_function(key)
        slot = self.table[hash_value]
        for i, (k, v) in enumerate(slot):
            if k == key:
                del slot[i]
                break
        else:
            raise KeyError(key)
```

#### Приоритетные очереди и способы их реализации
Чтобы понять приоритетные очереди в Python, нам нужно сначала понять, что такое очередь.

Очередь — это структура данных, в которой элементы хранятся в порядке «первым поступил — первым обслужен» (FIFO). 
Это означает, что первый элемент, добавленный в очередь, будет первым элементом, который будет удален. Очереди могут 
быть реализованы с помощью списков или очередей в Python.  

Теперь приоритетная очередь — это разновидность очереди, в которой каждый элемент имеет связанный с ним приоритет. 
Элементы удаляются из очереди в порядке их приоритета, а не в порядке их добавления. Другими словами, элемент с 
наивысшим приоритетом удаляется первым.  

В Python мы можем реализовать приоритетную очередь, используя модуль heapq, который предоставляет функции для 
создания структур данных кучи и управления ими. Куча — это двоичная древовидная структура, в которой каждый узел 
имеет значение приоритета, а его дочерние элементы имеют значения приоритета, которые ниже или равны родительскому 
узлу.

Модуль heapq предоставляет такие функции, как heappush для добавления элемента в очередь приоритетов, heappop для 
удаления элемента с наивысшим приоритетом и heapreplace для замены элемента с наивысшим приоритетом новым элементом.  

Прежде всего, в Python существуют несколько способов реализации приоритетных очередей:

- Использование встроенного модуля heapq
- Использование классической реализации на основе двоичной кучи (binary heap)
- Использование модуля queue с аргументом PriorityQueue
Для примера кода и дальнейшего описания выберем первый способ - использование модуля heapq.
```python
'''В этом примере мы создаем список чисел, который затем преобразуем в кучу с помощью функции heapq.heapify(). Затем 
мы поочередно извлекаем элементы из кучи с помощью функции heapq.heappop(), которая всегда извлекает минимальный 
элемент.
'''
import heapq

# Создаем некоторые данные
data = [5, 3, 7, 1, 2, 8, 4]

# Преобразуем список в кучу (heap)
heapq.heapify(data)

# Извлекаем элементы из кучи
while data:
    print(heapq.heappop(data))
```

```python
import heapq

# создадим пустую кучу
heap = []

# добавить элементы в кучу со значениями приоритета
heapq.heappush(heap, (1, 'first element'))
heapq.heappush(heap, (3, 'third element'))
heapq.heappush(heap, (2, 'second element'))

# удалим элементы из кучи по приоритету
print(heapq.heappop(heap))  # (1, 'first element')
print(heapq.heappop(heap))  # (2, 'second element')
print(heapq.heappop(heap))  # (3, 'third element')
```

### Знание расширенных структур данных
#### B-дерево
B-дерево - это структура данных, которая используется для хранения и упорядочения больших объемов данных. Оно 
является сбалансированным деревом, то есть каждая ветвь содержит примерно одинаковое число элементов. Особенностью 
B-дерева является наличие нескольких ключей на узле, что позволяет улучшить эффективность поиска данных.
Б-дерево - это сбалансированное дерево поиска, которое предназначено для уменьшения количества обращений к диску при 
поиске данных на жестком диске. Оно состоит из узлов разного размера, которые хранят ключи и ссылки на другие узлы. 


Пример реализации B-дерева на языке Python:
```python
'''Это минимальная реализация классов BNode и BTree на Python. Она позволяет вставлять новые элементы в дерево и 
выводить его содержимое на экран. В данной реализации используется параметр t, который определяет минимальное 
количество ключей на узле.  
'''
class BNode:
    def __init__(self, leaf=False):
        self.leaf = leaf
        self.keys = []
        self.child = []


class BTree:
    def __init__(self, t):
        self.root = BNode(True)
        self.t = t

    def insert(self, k):
        root = self.root
        if len(root.keys) == (2 * self.t) - 1:
            new_root = BNode()
            self.root = new_root
            new_root.child.insert(0, root)
            self._split(new_root, 0)
            self._insert_non_full(new_root, k)
        else:
            self._insert_non_full(root, k)

    def _insert_non_full(self, node, k):
        i = len(node.keys) - 1
        if node.leaf:
            node.keys.append(0)
            while i >= 0 and k < node.keys[i]:
                node.keys[i+1] = node.keys[i]
                i -= 1
            node.keys[i+1] = k
        else:
            while i >= 0 and k < node.keys[i]:
                i -= 1
            if len(node.child[i+1].keys) == (2*self.t)-1:
                self._split(node, i+1)
                if k > node.keys[i+1]:
                    i += 1
            self._insert_non_full(node.child[i+1], k)

    def _split(self, node, i):
        t = self.t
        y = node.child[i]
        z = BNode(y.leaf)
        node.child.insert(i+1, z)
        node.keys.insert(i, y.keys[t-1])
        z.keys = y.keys[t:(2*t)-1]
        y.keys = y.keys[0:t-1]
        z.child = y.child[t:(2*t)]
        y.child = y.child[0:t-1]

    def print_tree(self, node=None, level=0):
        if node is None:
            node = self.root

        print('Level', level, '->', len(node.keys), end=":")
        for i in node.keys:
            print(i, end=' ')
        print()

        if not node.leaf:
            for i in node.child:
                self.print_tree(i, level + 1)
```



Вот пример реализации Б-дерева и его использования на Python:
```python
'''В этом коде мы определяем класс «BTreeNode», который представляет собой узел Б-дерева. Узел содержит список 
ключей и ссылки на другие узлы. Класс «BTree» представляет собой само дерево. Метод «insert» вставляет новый ключ в 
дерево, метод «_split_child» разделяет узел и метод «_insert_nonfull» вставляет новый ключ в неполный узел.  '''
class BTreeNode:
    def __init__(self, leaf=False):
        self.leaf = leaf
        self.keys = []
        self.child = []

class BTree:
    def __init__(self, degree):
        self.root = BTreeNode(True)
        self.degree = degree

    def insert(self, k):
        r = self.root
        if len(r.keys) == (2*self.degree)-1:
            s = BTreeNode()
            self.root = s
            s.child.insert(0, r)
            self._split_child(s, 0)
            self._insert_nonfull(s, k)
        else:
            self._insert_nonfull(r, k)

    def _insert_nonfull(self, x, k):
        i = len(x.keys)-1
        if x.leaf:
            x.keys.append(0)
            while i >= 0 and k < x.keys[i]:
                x.keys[i+1] = x.keys[i]
                i -= 1
            x.keys[i+1] = k
        else:
            while i >= 0 and k < x.keys[i]:
                i -= 1
            i += 1
            if len(x.child[i].keys) == (2*self.degree)-1:
                self._split_child(x, i)
                if k > x.keys[i]:
                    i += 1
            self._insert_nonfull(x.child[i], k)

    def _split_child(self, x, i):
        t = self.degree
        y = x.child[i]
        z = BTreeNode(leaf=y.leaf)

        x.child.insert(i+1, z)
        x.keys.insert(i, y.keys[t-1])

        z.keys = y.keys[t:(2*t)-1]
        y.keys = y.keys[0:t-1]

        if not y.leaf:
            z.child = y.child[t:(2*t)]
            y.child = y.child[0:t-1]

    def search(self, k, x=None):
        if isinstance(x, BTreeNode):
            i = 0
            while i < len(x.keys) and k > x.keys[i]:
                i += 1
            if i < len(x.keys) and k == x.keys[i]:
                return x, i
            elif x.leaf:
                return None
            else:
                return self.search(k, x.child[i])
        else:
            return self.search(k, self.root)

    def __str__(self):
        r = self.root
        return self._to_string(r)

    def _to_string(self, x, lvl=0):
        ret = " " * lvl
        if x is None:
            return ret + "None\n"
        else:
            if x.leaf:
                ret += "Leaf -> "
            else:
                ret += "Node -> "
            ret += str(x.keys) + "\n"
            for i in range(len(x.child)):
                ret += self._to_string(x.child[i], lvl + 1)
            return ret

'''В этом примере мы создаем Б-дерево с минимальной степенью 3 и вставляем несколько ключей в дерево. Затем мы 
выполняем поиск ключей в дереве с помощью метода «search». Если ключ находится в дереве, метод «search» возвращает 
узел и индекс ключа в этом узле. Если ключ не найден, метод возвращает значение None.   
'''
t = BTree(3)
t.insert(8)
t.insert(18)
t.insert(2)
t.insert(1)
t.insert(20)
t.insert(50)
t.insert(23)

print(t.search(2))
print(t.search(23))
print(t.search(300))
```

#### Биномиальная куча 
Биномиальная куча (binomial heap) - это структура данных, которая представляет собой лес биномиальных деревьев. Она 
позволяет эффективно добавлять, удалять и обновлять элементы, а также искать минимальный элемент. 

Биномиальный лес – это семейство биномиальных деревьев.

Биномиальное дерево высоты h = 0 состоит из одной единственной вершины, биномиальное дерево Bk высоты h = k 
образуется присоединением биномиального дерева высоты k-1 к корню другого биномиального дерева высоты k-1. Ниже 
показаны биномиальные деревья B0, B1, B2, B3 и B4.  

<img src="./art/binom_ex_1.jpg" alt="Bot logo" width="400" height="300">

Ниже приведена простая реализация биномиальной кучи на языке Python.
```python
'''В этой реализации биномиальной кучи используется вложенный класс Node, который представляет вершину биномиального 
дерева. Куча хранится как односвязный список биномиальных деревьев в порядке убывания их размеров. Операция 
объединения двух биномиальных деревьев происходит с помощью рекурсивного объединения их корневых списков. Операция 
удаления минимального элемента происходит поиском минимального узла в списке и его последующим удалением.   
'''
class BinomialHeap:
    class Node:
        def __init__(self, key, value):
            self.key = key
            self.value = value
            self.degree = 0
            self.parent = None
            self.child = None
            self.sibling = None
    
    def __init__(self):
        self.head = None
    
    def push(self, key, value):
        new_node = self.Node(key, value)
        self.head = self._merge_lists(self.head, new_node)
    
    def pop(self):
        if not self.head:
            return None
        
        min_node = self.head
        prev_node = None
        curr_node = min_node
        
        while curr_node.sibling:
            if curr_node.sibling.key < min_node.key:
                min_node = curr_node.sibling
                prev_node = curr_node
            curr_node = curr_node.sibling
        
        if prev_node:
            prev_node.sibling = min_node.sibling
        elif min_node == self.head:
            self.head = min_node.sibling
        
        child_head = min_node.child
        if child_head:
            child_head.parent = None
            curr_node = child_head
            while curr_node:
                next_node = curr_node.sibling
                curr_node.sibling = curr_node.parent = None
                self.head = self._merge_lists(self.head, curr_node)
                curr_node = next_node
        
        return min_node.value
    
    def peek(self):
        return self.head.value if self.head else None
    
    def _merge_lists(self, head1, head2):
        if not head1:
            return head2
        if not head2:
            return head1
        
        if head1.key < head2.key:
            head1.sibling = self._merge_lists(head1.sibling, head2)
            return head1
        else:
            head2.sibling = self._merge_lists(head2.sibling, head1)
            return head2
```